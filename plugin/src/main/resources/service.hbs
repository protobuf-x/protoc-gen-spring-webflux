// Generated by the {{pluginName}} compiler plugin.  DO NOT EDIT!
// source: {{protoSourceName}}
package {{pkgName}};

import com.google.common.base.Strings;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.Message;
import com.google.protobuf.MessageOrBuilder;
import com.google.protobuf.util.JsonFormat;
import io.grpc.Metadata;
import io.grpc.stub.MetadataUtils;
import io.grpc.stub.StreamObserver;
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import org.springframework.web.server.ServerWebInputException;
import reactor.core.publisher.BaseSubscriber;
import reactor.core.publisher.Mono;

import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

@javax.annotation.Generated(
        value = "by {{pluginName}} compiler plugin",
        comments = "Source: {{protoSourceName}}")
public final class {{outerClassName}} {

    private {{outerClassName}}() {}

    public interface {{serviceClassName}} {

        /**
         * Offers all route for service.
         */
        @javax.annotation.Nonnull
        default public RouterFunction<ServerResponse> allRoutes() {
                return RouterFunctions.route()
                    {{#routeDefinitions}}
                    .{{methodTypeName}}("{{path}}", this::{{restMethodName}})
                    {{/routeDefinitions}}
                    .build();
        }

        {{#methods}}
        /**
        {{#if comments}}
        <pre>
        {{#comments}}
        * {{.}}
        {{/comments}}
        </pre>
        {{/if}}
        */
        @javax.annotation.Nonnull
        default public Mono<ServerResponse> {{restMethodName}}(ServerRequest serverRequest) {
            return ServerResponse.status(HttpStatus.NOT_IMPLEMENTED).build();
        }
        {{/methods}}
    }

    /**
     * Creates a new grpc-proxy handler builder that supports all call types for the service.
     */
    public static {{outerClassName}}.{{serviceGrpcProxyClassName}}.Builder newGrpcProxyBuilder() {
      return new {{outerClassName}}.{{serviceGrpcProxyClassName}}.Builder();
    }

    public static final class {{serviceGrpcProxyClassName}} implements {{serviceClassName}} {

        private {{package}}.{{serviceName}}Grpc.{{serviceName}}Stub stub;
        private List<String> includeHeaders;
        private JsonFormat.Parser jsonParser;
        private JsonFormat.Printer jsonPrinter;

        {{#methods}}
        @javax.annotation.Nonnull
        @java.lang.Override
        public Mono<ServerResponse> {{restMethodName}}(ServerRequest serverRequest) {
            try {
                {{#with requestContext}}
                return Mono.just({{requestType}}.newBuilder())
                        {{#with body}}
                        .flatMap(inputBuilder -> {
                            return serverRequest
                                .bodyToMono(String.class)
                                .map(jsonString -> {
                                    {{#if wildcard}}
                                        mergeJson(jsonString, inputBuilder);
                                    {{else}}
                                        {{type}}.Builder builder = {{type}}.newBuilder();
                                        mergeJson(jsonString, builder);
                                        inputBuilder{{setterName}}(builder.build());
                                    {{/if}}
                                    return inputBuilder;
                                });
                        })
                        {{/with}}
                        {{#parameters}}
                        .map(inputBuilder -> {
                            List<{{type}}> {{variable}} = param(serverRequest, "{{variable}}", p -> {{convert}});
                            {{#if isRepeated}}
                                inputBuilder{{setterName}}({{variable}});
                            {{else}}
                                if ({{variable}}.size() != 0) {
                                    inputBuilder{{setterName}}({{variable}}.get(0));
                                }
                            {{/if}}
                            return inputBuilder;
                        })
                        {{/parameters}}
                        {{#paths}}
                        .map(inputBuilder -> {
                            {{type}} {{variable}} = query(serverRequest, "{{variable}}", p -> {{convert}});
                            inputBuilder{{setterName}}({{variable}});
                            return inputBuilder;
                        })
                        {{/paths}}
                        .map({{requestType}}.Builder::build)
                {{/with}}
                        .flatMap(request -> {
                            return Mono.<{{resultProto}}>create(emitter -> {
                                Metadata metadata = extractMetadata(serverRequest.headers());
                                stub.withInterceptors(MetadataUtils.newAttachHeadersInterceptor(metadata)).{{methodName}}(request, new StreamObserver<{{resultProto}}>() {
                                    @Override
                                    public void onNext({{resultProto}} value) {
                                        emitter.success(value);
                                    }

                                    @Override
                                    public void onError(Throwable t) {
                                        emitter.error(t);
                                    }

                                    @Override
                                    public void onCompleted() {
                                        // Do nothing
                                    }
                                });
                            });
                        })
                        .flatMap(res -> ServerResponse.ok()
                                .contentType(MediaType.APPLICATION_JSON)
                                .bodyValue(printJson(res.toBuilder())));
            } catch (Exception e) {
                return Mono.error(e);
            }
        }
        {{/methods}}

        @javax.annotation.Nonnull
        private <T> T query(ServerRequest serverRequest, String target, Convert<T> convert) {
            try {
              return convert.apply(serverRequest.pathVariable(target));
            } catch (Exception e) {
              throw new ServerWebInputException(e.getMessage());
            }
        }

        @javax.annotation.Nonnull
        private <T> List<T> param(ServerRequest serverRequest, String param, Convert<T> converter) {
            List<String> params = serverRequest.queryParams().get(param);
            if (params == null) {
                return Collections.emptyList();
            }
            List<T> result = new ArrayList<>();
            for (String p : params) {
                if (!Strings.isNullOrEmpty(p)) {
                    try {
                        result.add(converter.apply(p));
                    } catch (Exception e) {
                        throw new ServerWebInputException(e.getMessage());
                    }
                }
            }
            return result;
        }

        private void mergeJson(String json, Message.Builder builder)  {
          try {
              jsonParser.merge(json, builder);
          } catch (IOException e) {
              throw new ServerWebInputException(e.getMessage());
          }
        }

        private String printJson(MessageOrBuilder message) {
          try {
              return jsonPrinter.print(message);
          } catch (InvalidProtocolBufferException e) {
              throw new IllegalArgumentException(e);
          }
        }

        private Metadata extractMetadata(ServerRequest.Headers headers) {
          Metadata metadata = new Metadata();
          if (Objects.nonNull(includeHeaders)) {
              headers.asHttpHeaders().entrySet()
                      .forEach(entity -> {
                            includeHeaders.forEach(header -> {
                                if (header.equalsIgnoreCase(entity.getKey())) {
                                    metadata.put(Metadata.Key.of(entity.getKey(), Metadata.ASCII_STRING_MARSHALLER),
                                            entity.getValue().get(0));
                                }
                            });
                      });
          }
          return metadata;
        }

        public static final class Builder {
          private {{package}}.{{serviceName}}Grpc.{{serviceName}}Stub stub;
          private List<String> includeHeaders;
          private JsonFormat.Parser jsonParser = JsonFormat.parser().ignoringUnknownFields();
          private JsonFormat.Printer jsonPrinter = JsonFormat.printer().includingDefaultValueFields();

          public {{serviceGrpcProxyClassName}} build() {
            {{serviceGrpcProxyClassName}} handler = new {{serviceGrpcProxyClassName}}();
            handler.stub = this.stub;
            handler.includeHeaders = this.includeHeaders;
            handler.jsonParser = jsonParser;
            handler.jsonPrinter = jsonPrinter;
            return handler;
          }

          public Builder setStub({{package}}.{{serviceName}}Grpc.{{serviceName}}Stub stub) {
            this.stub = stub;
            return this;
          }

          public Builder setIncludeHeaders(List<String> includeHeaders) {
            this.includeHeaders = includeHeaders;
            return this;
          }

          public Builder setJsonParser(JsonFormat.Parser jsonParser) {
            this.jsonParser = jsonParser;
            return this;
          }

          public Builder setJsonPrinter(JsonFormat.Printer jsonPrinter) {
            this.jsonPrinter = jsonPrinter;
            return this;
          }
        }

        private interface Convert<R> {
            R apply(String target) throws Exception;
        }
    }
}
